# Palindrome Free Strings
# https://codingcompetitions.withgoogle.com/kickstart/round/00000000008cb33e/00000000009e762e
# Key idea: If there's a palindromic substring P and |P| > 6, then it must also contain a palindromic substring of length 5 or 6
# If we have a valid prefix, only the last 5 characters determine whether it is possible to append a 0 or 1 without introducing a palindrome
# Thus all valid strings can be generated by a finite state machine with exactly 24 states (32 5-character strings, minus 8 palindromes)
# Transition from abcde to bcdef is possible if and only if neither abcde nor bcdef is a 5-character palindrome and abcdef is not a 6-character palindrome
# Bottom-up DP, processing bits from left to right, while maintaining possible prefixes to last 5 bits
# O(2^5 * N) = O(N), O(2^5) = O(1) space

palindrome5 = [0, 4, 10, 14, 17, 21, 27, 31]
# b00000 = 0, b00100 = 4, b01010 = 10, b01110 = 14, b10001 = 17, b10101 = 21, b11011 = 27, b11111 = 31
palindrome6 = [0, 12, 18, 30, 33, 45, 51, 63]
# b000000 = 0, b001100 = 12, b010010 = 18, b011110 = 30, b100001 = 33, b101101 = 45, b110011 = 51, b111111 = 63
MASK = (1 << 5) - 1 # 11111, 5 1's, for taking only last 5 bits

M = pow(2, 5)
T = int(input())
for t in range(T):
    N = int(input())
    S = list(input())

    if N < 5:
        print(f"Case #{t + 1}: POSSIBLE")
    else:
        candidates = [0]
        for i in range(5):
            next = []
            if S[i] == '0':
                for n in candidates:
                    next.append(n << 1)
            elif S[i] == '1':
                for n in candidates:
                    next.append(n << 1 | 1)
            elif S[i] == '?':
                for n in candidates:
                    next.append(n << 1)
                    next.append(n << 1 | 1)
            candidates = next
        for n in palindrome5:
            if n in candidates:
                candidates.remove(n)

        for i in range(5, N):
            next = []
            if S[i] == '0':
                for n in candidates:
                    if (n << 1) not in palindrome6 and (n << 1) & MASK not in palindrome5:
                        next.append((n << 1) & MASK)
            elif S[i] == '1':
                for n in candidates:
                    if (n << 1 | 1) not in palindrome6 and (n << 1 | 1) & MASK not in palindrome5:
                        next.append((n << 1 | 1) & MASK)
            elif S[i] == '?':
                for n in candidates:
                    if (n << 1) not in palindrome6 and (n << 1) & MASK not in palindrome5:
                        next.append((n << 1) & MASK)
                    if (n << 1 | 1) not in palindrome6 and (n << 1 | 1) & MASK not in palindrome5:
                        next.append((n << 1 | 1) & MASK)
            candidates = next
            # print([format(bits, "05b") for bits in candidates])

        if candidates:
            print(f"Case #{t + 1}: POSSIBLE")
        else:
            print(f"Case #{t + 1}: IMPOSSIBLE")
