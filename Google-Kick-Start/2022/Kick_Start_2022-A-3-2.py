# Palindrome Free Strings
# https://codingcompetitions.withgoogle.com/kickstart/round/00000000008cb33e/00000000009e762e
# Key idea: If there's a palindromic substring P and |P| > 6, then it must also contain a palindromic substring of length 5 or 6
# If we have a valid prefix, only the last 5 characters determine whether it is possible to append a 0 or 1 without introducing a palindrome
# Thus all valid strings can be generated by a finite state machine with exactly 24 states (32 5-character strings, minus 8 palindromes)
# Transition from abcde to bcdef is possible if and only if neither abcde nor bcdef is a 5-character palindrome and abcdef is not a 6-character palindrome
# DP, O(2^5 * N) = O(N), O(2^5 * N) = O(N) space

palindrome5 = [0, 4, 10, 14, 17, 21, 27, 31]
# b00000 = 0, b00100 = 4, b01010 = 10, b01110 = 14, b10001 = 17, b10101 = 21, b11011 = 27, b11111 = 31
palindrome6 = [0, 12, 18, 30, 33, 45, 51, 63]
# b000000 = 0, b001100 = 12, b010010 = 18, b011110 = 30, b100001 = 33, b101101 = 45, b110011 = 51, b111111 = 63
MASK = (1 << 5) - 1 # 11111, 5 1's, for taking only last 5 bits

# Converting last 5 bits to int, and ignore bits which is palindrome
def get_candidates(bits: list):
    candidates = [0]
    for i in range(5):
        next = []
        if bits[i] == '0':
            for n in candidates:
                next.append(n << 1)
        elif bits[i] == '1':
            for n in candidates:
                next.append(n << 1 | 1)
        elif bits[i] == '?':
            for n in candidates:
                next.append(n << 1)
                next.append(n << 1 | 1)
        candidates = next
    for n in palindrome5:
        if n in candidates:
            candidates.remove(n)
    return candidates

M = pow(2, 5)
T = int(input())
for t in range(T):
    N = int(input())
    S = list(input())

    if N < 5:
        ans = True
    else:
        dp = [[False] * M for _ in range(N - 4)]
        # dp[i][b]: with last 5 bits as b, starting from i-th bit, whether it's possible to form valid string
        # DP initial state, check last 5 bits of string
        candidates = get_candidates(S[N-5:])
        # print(candidates)
        # print([format(bits, "05b") for bits in candidates])
        for bits in candidates:
            dp[N - 5][bits] = True

        for i in range(N - 6, -1, -1):
            candidates = get_candidates(S[i:i+5])
            for bits in candidates:
                next = bits << 1 # Append 0
                if next not in palindrome6:
                    dp[i][bits] |= dp[i+1][next & MASK]
                next = (bits << 1) | 1 # Append 1
                if next not in palindrome6:
                    dp[i][bits] |= dp[i+1][next & MASK]

        ans = False
        for i in range(M):
            ans |= dp[0][i]

    if ans:
        print(f"Case #{t + 1}: POSSIBLE")
    else:
        print(f"Case #{t + 1}: IMPOSSIBLE")
